# Do simulation
for(m in 1:length(M)){
for(s in 1:length(sigma)){
t <- seq(0, 1, length.out = M[m] + 1) # Design points
simulation_ <- rerun(N, quadratic_trajectory(M[m], sigma[s], hetero_noise, hetero_func))
mean_ <- true_mean(t)
covariance_ <- true_covariance(t, t)
quadratic.trajectories <- list(
simulation = simulation_,
mean = mean_,
covariance = covariance_
)
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
saveRDS(quadratic.trajectories,
file = paste0('./data/quadratic.trajectories-', M[m], '-', sigma[s], '-hetero3.rds'))
}
}
######################################################################################
#                       Generate fractional Brownian motion                          #
######################################################################################
# Load packages
library(tidyverse)
# Define functions
#' Generate fractional Brownian motion with a random noise.
#'
#' @param M Number of points in the trajectory
#' @param sigma Standard deviation of the noise to add to the trajectory
#' @param H Hurst coefficient
#' @param hetero_noise Should the moise be heteroscedastic? (default = FALSE)
#' @param hetero_func A function to generate the noise
#' @return A tibble containing the trajectory and the sampling points.
fractional_brownian_trajectory <- function(M, H, sigma, hetero_noise = FALSE, hetero_func = NULL){
require(somebm)
if(is.null(hetero_func)){
sd.function <- function(t) (abs(t)+1)**(5/6)
} else{
sd.function <- hetero_func
}
M_n <- rpois(1, M)
t <- seq(0, 1, length.out = M_n + 1)
e <- rnorm(M_n + 1, mean = 0, sd = sigma)
x <- as.vector(fbm(hurst = H, n = M_n))
if(hetero_noise) e <- sd.function((x - median(x)) / sd(x)) * e
return(tibble(t = t, x = x + e))
}
#' Compute the true mean of the generated fractional Brownian motion.
#'
#' @param t A vector of sampling points
#' @return A tibble containing the true mean trajectory and the sampling points.
true_mean <- function(t){
x <- rep(0, length(t))
return(tibble(t = t, x = x))
}
#' Compute the true covariance of the generated fractional Brownian motion.
#'
#' @param s_ A vector of sampling points
#' @param t_ A vector of sampling points
#' @param H Hurst coefficient
#' @return A tibble containing the true covariance for each pair (s, t)
true_covariance <- function(s_, t_, H){
res <- tibble(
s = rep(s_, times = length(t_)),
t = rep(t_, each = length(s_))) %>%
mutate(phi = (abs(s)**(2*H) + abs(t)**(2*H) - abs(t - s)*(2*H))/2)
return(res)
}
# Define some parameters
N <- 10000 # Number of curves
M <- c(50, 200, 1000)  # Number of points per curves (do it with 50, 200, 1000)
H <- c(0.4, 0.5, 0.6) # Hurst coefficient (do it with 0.4, 0.5, 0.6)
sigma <- c(0, 0.01, 0.05, 0.1) # Standard deviation of the noise (do it with 0, 0.01, 0.05, 0.1)
hetero_noise <- TRUE # Add heteroscedastic noise?
hetero_func <- function(x) return (2 * exp(abs(x)) / (1 + exp(abs(x))) - 0.5)
# Do simulation
for(m in 1:length(M)){
for(h in 1:length(H)){
for(s in 1:length(sigma)){
t <- seq(0, 1, length.out = M[m] + 1) # Design points
simulation_ <- rerun(N, fractional_brownian_trajectory(M[m], H[h], sigma[s], hetero_noise, hetero_func))
mean_ <- true_mean(t)
covariance_ <- true_covariance(t, t, H[h])
fractional.brownian.trajectories <- list(
simulation = simulation_,
mean = mean_,
covariance = covariance_
)
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
saveRDS(fractional.brownian.trajectories,
file = paste0('./data/fractional.brownian.trajectories-', M[m], '-', H[h], '-', sigma[s], '-hetero3.rds'))
}
}
}
# Save data
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
#usethis::use_data(fractional.brownian.trajectories, overwrite = TRUE)
Rcpp::sourceCpp('src/estimate_risk.cpp')
load("~/Documents/workspace/CovarianceEstimate/test.RData")
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
a <- estimateRisk(S_N, curves_estim)
a
a[0,1]
Rcpp::sourceCpp('src/estimate_risk.cpp')
a
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
View(a)
S_N[[1]]$t
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
S_N[[1]]$x
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
S_N[[1]]$t
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
Rcpp::sourceCpp('src/estimate_risk.cpp')
sqrt(28)
`fractional.brownian.trajectories-1000-0.6-0.01.0.05.0.1.0.25` <- readRDS("~/Documents/workspace/CovarianceEstimate/data/fractional.brownian.trajectories-1000-0.6-0.01.0.05.0.1.0.25.rds")
rm(`fractional.brownian.trajectories-1000-0.6-0.01.0.05.0.1.0.25`)
Rcpp::sourceCpp('src/mfBm.cpp')
length(seq(0.1, 0.9, 0.01))
Rcpp::sourceCpp('src/mfBm.cpp')
Rcpp::sourceCpp('src/mfBm.cpp')
plot(mfBm(seq(0.1, 0.9, 0.01), seq(from=0,to=1,length=81), 20, 81))
plot(mfBm(0.5, seq(from=0,to=1,length=1000), 5000, 1000))
plot(mfBm(0.5, seq(from=0,to=1,length=1000), 1000, 1000))
substract_element <- function(v, t, i, t0){
idx <- sum(t <= t0)
return((v[2*i + 1 + idx] - v[1 + idx])**2 - (v[i + 1 + idx] - v[1 + idx])**2)
}
Rcpp::sourceCpp('src/mfBm.cpp')
plot(mfBm(rep(0.5, 1000), seq(from=0,to=1,length=1000), 1000, 50))
a = NULLis.null(a)
a = NULL
is.null(a)
!is.null(a)
library(tidyverse)
rm(a)
1 / log(200)
source('~/Documents/workspace/CovarianceEstimate/R/estimate.risk.R')
View(estimate.risk)
Rcpp::sourceCpp('./src/estimate_risk.cpp')
#' Perform the estimation of the risk on a set of curves.
#'
#' @param curves List of (true) curves.
#' @param curves_estim List of estimated curves.
#' @param t0 The time point where to compute the risk
#' @return List with the mean and max residual squared error in t0.
estimate.risk <- function(curves, curves_estim, t0 = 0.5){
# Estimate the risk
risk <- estimateRisk(curves, curves_estim, t0)
#return(c('MeanRSE' = risk[1], 'MaxRSE' = risk[2]))
return(risk)
}
estimateRisk
log(1e-5)
source('~/Documents/workspace/CovarianceEstimate/R/estimate.H0.R')
######################################################################################
#                       Generate fractional Brownian motion                          #
######################################################################################
# Load packages
library(tidyverse)
# Define functions
#' Generate fractional Brownian motion with a random noise.
#'
#' @param M Number of points in the trajectory
#' @param sigma Standard deviation of the noise to add to the trajectory, can be a list.
#' @param H Hurst coefficient
#' @param hetero_func A function to generate the noise
#' @return A tibble containing the trajectory and the sampling points.
fractional_brownian_trajectory <- function(M, H, sigma, hetero_func = NULL){
require(somebm)
if(is.null(hetero_func)){
sd.function <- function(t) (abs(t)+1)**(5/6)
} else{
sd.function <- hetero_func
}
M_n <- rpois(1, M)
t <- seq(0, 1, length.out = M_n + 1)
x <- as.vector(fbm(hurst = H, n = M_n))
# Start to fill the data
simu <- matrix(rep(0, (M_n + 1) * (length(sigma) + 3)), nrow = M_n + 1)
simu[, 1] <- t
simu[, 2] <- x
# Add columns with homoscedastic noise.
j <- 3
for(i in sigma){
e <- rnorm(M_n + 1, mean = 0, sd = i)
simu[, j] <- x + e
j = j + 1
}
# Add a column with heteroscedastique noise.
e <- sd.function((x - median(x)) / sd(x)) * rnorm(M_n + 1, mean = 0, sd = 0.05)
simu[, ncol(simu)] <- x + e
return(as_tibble(simu, .name_repair = 'unique'))
}
#' Compute the true mean of the generated fractional Brownian motion.
#'
#' @param t A vector of sampling points
#' @return A tibble containing the true mean trajectory and the sampling points.
true_mean <- function(t){
x <- rep(0, length(t))
return(tibble(t = t, x = x))
}
#' Compute the true covariance of the generated fractional Brownian motion.
#'
#' @param s_ A vector of sampling points
#' @param t_ A vector of sampling points
#' @param H Hurst coefficient
#' @return A tibble containing the true covariance for each pair (s, t)
true_covariance <- function(s_, t_, H){
res <- tibble(
s = rep(s_, times = length(t_)),
t = rep(t_, each = length(s_))) %>%
mutate(phi = (abs(s)**(2*H) + abs(t)**(2*H) - abs(t - s)*(2*H))/2)
return(res)
}
# Define some parameters
N <- 10000 # Number of curves
M <- c(200)  # Number of points per curves (do it with 50, 200, 1000)
H <- c(0.5) # Hurst coefficient (do it with 0.4, 0.5, 0.6)
sigma <- c(1) # Standard deviation of the noise (do it with 0.01, 0.05, 0.1, 0.25)
hetero_func <- function(x) return (2 * exp(abs(x)) / (1 + exp(abs(x))) - 0.5)
# Do simulation
for(m in 1:length(M)){
t <- seq(0, 1, length.out = M[m] + 1) # Design points
simulation_ <- rerun(N, fractional_brownian_trajectory(M[m], H[3], sigma, hetero_func))
mean_ <- true_mean(t)
covariance_ <- true_covariance(t, t, H[3])
fractional.brownian.trajectories <- list(
simulation = simulation_,
mean = mean_,
covariance = covariance_
)
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
saveRDS(fractional.brownian.trajectories,
file = paste0('./data/fractional.brownian.trajectories-', M[m], '-', H[3], '-', paste(sigma, collapse = '.'), '.rds'))
}
# Save data
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
#usethis::use_data(fractional.brownian.trajectories, overwrite = TRUE)
# Define some parameters
N <- 10000 # Number of curves
M <- c(200)  # Number of points per curves (do it with 50, 200, 1000)
H <- c(0.5) # Hurst coefficient (do it with 0.4, 0.5, 0.6)
sigma <- c(1) # Standard deviation of the noise (do it with 0.01, 0.05, 0.1, 0.25)
hetero_func <- function(x) return (2 * exp(abs(x)) / (1 + exp(abs(x))) - 0.5)
length(M)
H
######################################################################################
#                       Generate fractional Brownian motion                          #
######################################################################################
# Load packages
library(tidyverse)
# Define functions
#' Generate fractional Brownian motion with a random noise.
#'
#' @param M Number of points in the trajectory
#' @param sigma Standard deviation of the noise to add to the trajectory, can be a list.
#' @param H Hurst coefficient
#' @param hetero_func A function to generate the noise
#' @return A tibble containing the trajectory and the sampling points.
fractional_brownian_trajectory <- function(M, H, sigma, hetero_func = NULL){
require(somebm)
if(is.null(hetero_func)){
sd.function <- function(t) (abs(t)+1)**(5/6)
} else{
sd.function <- hetero_func
}
M_n <- rpois(1, M)
t <- seq(0, 1, length.out = M_n + 1)
x <- as.vector(fbm(hurst = H, n = M_n))
# Start to fill the data
simu <- matrix(rep(0, (M_n + 1) * (length(sigma) + 3)), nrow = M_n + 1)
simu[, 1] <- t
simu[, 2] <- x
# Add columns with homoscedastic noise.
j <- 3
for(i in sigma){
e <- rnorm(M_n + 1, mean = 0, sd = i)
simu[, j] <- x + e
j = j + 1
}
# Add a column with heteroscedastique noise.
e <- sd.function((x - median(x)) / sd(x)) * rnorm(M_n + 1, mean = 0, sd = 0.05)
simu[, ncol(simu)] <- x + e
return(as_tibble(simu, .name_repair = 'unique'))
}
#' Compute the true mean of the generated fractional Brownian motion.
#'
#' @param t A vector of sampling points
#' @return A tibble containing the true mean trajectory and the sampling points.
true_mean <- function(t){
x <- rep(0, length(t))
return(tibble(t = t, x = x))
}
#' Compute the true covariance of the generated fractional Brownian motion.
#'
#' @param s_ A vector of sampling points
#' @param t_ A vector of sampling points
#' @param H Hurst coefficient
#' @return A tibble containing the true covariance for each pair (s, t)
true_covariance <- function(s_, t_, H){
res <- tibble(
s = rep(s_, times = length(t_)),
t = rep(t_, each = length(s_))) %>%
mutate(phi = (abs(s)**(2*H) + abs(t)**(2*H) - abs(t - s)*(2*H))/2)
return(res)
}
# Define some parameters
N <- 10000 # Number of curves
M <- c(200)  # Number of points per curves (do it with 50, 200, 1000)
H <- c(0.5) # Hurst coefficient (do it with 0.4, 0.5, 0.6)
sigma <- c(1) # Standard deviation of the noise (do it with 0.01, 0.05, 0.1, 0.25)
hetero_func <- function(x) return (2 * exp(abs(x)) / (1 + exp(abs(x))) - 0.5)
# Do simulation
for(m in 1:length(M)){
t <- seq(0, 1, length.out = M[m] + 1) # Design points
simulation_ <- rerun(N, fractional_brownian_trajectory(M[m], H, sigma, hetero_func))
mean_ <- true_mean(t)
covariance_ <- true_covariance(t, t, H)
fractional.brownian.trajectories <- list(
simulation = simulation_,
mean = mean_,
covariance = covariance_
)
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
saveRDS(fractional.brownian.trajectories,
file = paste0('./data/fractional.brownian.trajectories-', M[m], '-', H, '-', paste(sigma, collapse = '.'), '.rds'))
}
# Load packages
library(tidyverse)
#' Generate fractional Brownian motion with a random noise.
#'
#' @param M Number of points in the trajectory
#' @param sigma Standard deviation of the noise to add to the trajectory, can be a list.
#' @param H Hurst coefficient
#' @param hetero_func A function to generate the noise
#' @return A tibble containing the trajectory and the sampling points.
fractional_brownian_trajectory <- function(M, H, sigma, hetero_func = NULL){
require(somebm)
if(is.null(hetero_func)){
sd.function <- function(t) (abs(t)+1)**(5/6)
} else{
sd.function <- hetero_func
}
M_n <- rpois(1, M)
t <- seq(0, 1, length.out = M_n + 1)
x <- as.vector(fbm(hurst = H, n = M_n))
# Start to fill the data
simu <- matrix(rep(0, (M_n + 1) * (length(sigma) + 3)), nrow = M_n + 1)
simu[, 1] <- t
simu[, 2] <- x
e <- rnorm(M_n + 1, mean = 0, sd = 1)
# Add columns with homoscedastic noise.
j <- 3
for(i in sigma){
simu[, j] <- x + i * e
j = j + 1
}
# Add a column with heteroscedastique noise.
e <- sd.function((x - median(x)) / sd(x)) * rnorm(M_n + 1, mean = 0, sd = 0.05)
simu[, ncol(simu)] <- x + e
return(as_tibble(simu, .name_repair = 'unique'))
}
#' Compute the true mean of the generated fractional Brownian motion.
#'
#' @param t A vector of sampling points
#' @return A tibble containing the true mean trajectory and the sampling points.
true_mean <- function(t){
x <- rep(0, length(t))
return(tibble(t = t, x = x))
}
#' Compute the true covariance of the generated fractional Brownian motion.
#'
#' @param s_ A vector of sampling points
#' @param t_ A vector of sampling points
#' @param H Hurst coefficient
#' @return A tibble containing the true covariance for each pair (s, t)
true_covariance <- function(s_, t_, H){
res <- tibble(
s = rep(s_, times = length(t_)),
t = rep(t_, each = length(s_))) %>%
mutate(phi = (abs(s)**(2*H) + abs(t)**(2*H) - abs(t - s)*(2*H))/2)
return(res)
}
# Define some parameters
N <- 10000 # Number of curves
M <- c(200)  # Number of points per curves (do it with 50, 200, 1000)
H <- c(0.5) # Hurst coefficient (do it with 0.4, 0.5, 0.6)
sigma <- c(0.1, 0.5, 1) # Standard deviation of the noise (do it with 0.01, 0.05, 0.1, 0.25)
hetero_func <- function(x) return (2 * exp(abs(x)) / (1 + exp(abs(x))) - 0.5)
# Do simulation
for(m in 1:length(M)){
t <- seq(0, 1, length.out = M[m] + 1) # Design points
simulation_ <- rerun(N, fractional_brownian_trajectory(M[m], H, sigma, hetero_func))
mean_ <- true_mean(t)
covariance_ <- true_covariance(t, t, H)
fractional.brownian.trajectories <- list(
simulation = simulation_,
mean = mean_,
covariance = covariance_
)
# Naming convention (fraction.brownian.trajectories-M-H-sigma)
saveRDS(fractional.brownian.trajectories,
file = paste0('./data/fractional.brownian.trajectories-', M[m], '-', H, '-', paste(sigma, collapse = '.'), '.rds'))
}
#' Perform the estimation of H0.
#'
#' @param data List of curves to estimate by kernel regression.
#' @param sigma True value of sigma
#'         If null, change estimate
#' @param t0 The starting time for the estimation of H0.
#'
#' @return An estimation of H0.
estimate.H0 <- function(data, sigma = NULL, k0 = 2, t0 = 0, method = 'forward'){
S_N <- data
# Estimate s_0
theta <- function(v, t, k, t0, method =  'forward'){
idx <- sum(t <= t0)
if(method == 'backward') idx <- ifelse(idx - (2 * k + 1) > 0, idx - (2 * k + 1), 0)
return((v[idx + 2*k - 1] - v[idx + k])**2)
}
substract_sigma <- function(nb, sigma=0) nb - 2*sigma**2
two_log_two <- 2*log(2)
if(is.null(sigma)){ # Case where sigma is unknown
a <- S_N %>%
map_dbl(~ theta(.x$x, .x$t, k = 4*k0 - 3, t0 = t0, method = method)) %>%
mean()
b <- S_N %>%
map_dbl(~ theta(.x$x, .x$t, k = 2*k0 - 1, t0 = t0, method = method)) %>%
mean()
c <- S_N %>%
map_dbl(~ theta(.x$x, .x$t, k = k0, t0 = t0, method = method)) %>%
mean()
first_part <- log(a - b)
second_part <- log(b - c)
} else{ # Case where sigma is known
first_part <- S_N %>%
map_dbl(~ theta(.x$x, .x$t, k = 3, t0 = t0, method = method)) %>%
mean() %>%
substract_sigma(sigma) %>%
max(c(., 1e-5)) %>%
log()
second_part <- S_N %>%
map_dbl(~ theta(.x$x, .x$t, k = 2, t0 = t0, method = method)) %>%
mean() %>%
substract_sigma(sigma) %>%
max(c(., 1e-5)) %>%
log()
}
H0_hat <- (first_part - second_part) / two_log_two
return(H0_hat)
}
library(tidyverse)
seq_len(5)
library(KernSmooth)
a <- seq(0, 1, 0.01)
b <- sin(2* pi * a) + rnorm(101, 0, 0.05)
plot(a, b)
locpoly(a, b, bandwidth = 0.01)
lines(locpoly(a, b, bandwidth = 0.01))
lines(locpoly(a, b, bandwidth = 0.01, degree = 2), col = 'red')
plot(a, b)
lines(locpoly(a, b, bandwidth = 0.01, degree = 2, gridsize = length(a)), col = 'red')
lines(locpoly(a, b, bandwidth = 0.05, degree = 2, gridsize = length(a)), col = 'red')
locpoly(a, b, bandwidth = 0.05, degree = 2, gridsize = length(a))
locpoly(a, b, bandwidth = 0.05, degree = 0, gridsize = length(a))
plot(locpoly(a, b, bandwidth = 0.05, degree = 0, gridsize = length(a)), col = 'green')
test <- locpoly(a, b, bandwidth = 0.05, degree = 0, gridsize = 2*length(a))
test <- locpoly(a, b, bandwidth = 0.05, degree = 0, gridsize = 10*length(a))
test$x
test <- locpoly(a, b, bandwidth = 0.05, degree = 0, gridsize = 10*length(a), binned = FALSE)
install.packages('locpol')
locPolSmootherC(a, b , a, 0.05, 2)
library(locpol)
locPolSmootherC(a, b , a, 0.05, 2)
locPolSmootherC(a, b , a, 0.05, 2, EpaK)
test <- locPolSmootherC(a, b , a, 0.05, 2, EpaK)
plot(a, b)
lines(a, test$beta0, col = 'red')
test <- locPolSmootherC(a, b , a, 0.01, 2, EpaK)
warnings()
test <- locPolSmootherC(a, b , a, 0.011, 2, EpaK)
test <- locpoly(a, b, 0.2, gridsize = 2*length(a), degree = 0)
test <- locpoly(a, b, bandwidth = 0.2, gridsize = 2*length(a), degree = 0)
test$y[which.min(abs(test$x - a))]
test$x - a
library(nprobust)
lprobust(b, a, eval = a, h = 0.05)
test <- lprobust(b, a, eval = a, h = 0.05)
test$Estimate
lines(seq(0, 1, 0.01), test$Estimate['tau.us'], col = 'green')
lines(seq(0, 1, 0.01), test$Estimate[,'tau.us'], col = 'green')
test <- lprobust(b, a, eval = a, h = 0.01)
lines(seq(0, 1, 0.01), test$Estimate[,'tau.us'], col = 'blue')
ksmooth(a, b, bandwidth = 0.05)
ksmooth(a, b, bandwidth = 0.01)
plot(a, b)
lines(a, ksmooth(a, b, bandwidth = 0.01)$y)
lines(a, ksmooth(a, b, bandwidth = 0.05)$y, col = 'red')
